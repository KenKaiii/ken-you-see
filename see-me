#!/bin/bash

# see-me - Intelligent Browser Console Logging
# Auto-detects project type and running dev servers
# Usage: npm run dev & see-me
# Version: 2.2.0

set -e

# Unified detection patterns for consistency across all functions
readonly NODE_SERVER_PATTERNS="(node.*live-server|node.*vite|node.*next|node.*webpack|node.*dev-server)"
readonly GO_SERVER_PATTERNS="(go run|air|\.\/[a-zA-Z0-9_-]+$|\.\/main$|[a-zA-Z0-9_-]+\.exe$|\.\/[a-zA-Z0-9_-]*server[a-zA-Z0-9_-]*$)"
readonly DEV_SERVER_PROCESS_NAMES="node|go|main|python*|Python*|ruby|Rails|php|nginx|http-server|webpack*|vite|next*|live-server"
readonly COMMON_DEV_PORTS=(3000 5173 8080 8000 3001 4000 5500 9000)

# Cleanup stale PID files on startup
cleanup_stale_pids() {
    if [ -d ".devlogger" ]; then
        for pid_file in .devlogger/*.pid; do
            if [ -f "$pid_file" ]; then
                local pid=$(cat "$pid_file" 2>/dev/null)
                if [ -n "$pid" ] && ! kill -0 "$pid" 2>/dev/null; then
                    # Process is dead, remove stale PID file
                    rm -f "$pid_file"
                fi
            fi
        done
    fi
}

show_help() {
    cat << EOF
see-me - Smart Browser Console Logging (v2.2.0)

USAGE:
    npm run dev & see-me        # Start monitoring - auto-detects new server port
    see-me crawl                # Run one-time crawl to discover errors (for agents)
    see-me logs                 # View captured browser logs with agent instructions
    see-me [PORT]               # Connect to specific port
    see-me stop                 # Stop logging services
    see-me status               # Show current status
    see-me version              # Show version information

WORKFLOWS:
    # Development: Start monitoring
    npm run dev & see-me        # Automatically detects the port from new server
    
    # Agent workflow: Error discovery and fixing
    see-me logs                 # View current errors with agent instructions
    # Agent fixes errors in code
    see-me crawl                # Triggers fresh crawl to discover remaining errors
    see-me logs                 # View updated results (fewer errors after fixes)
    
    # Explicit port
    see-me 8080                 # Connect to port 8080 specifically

FEATURES:
    ‚úÖ Detects newly started dev servers automatically
    ‚úÖ Works with any framework (React, Django, Python, Node, etc.)
    ‚úÖ Browser console log capture with proxy injection
    ‚úÖ Agent-controlled crawling: tests all interactive elements on command
    ‚úÖ Smart error deduplication with occurrence counts
    ‚úÖ Session-based log separation for clean agent context
    ‚úÖ Agent-readable log files with clear instructions

EXAMPLE:
    npm run dev & see-me
    # Visit http://localhost:3334 instead of your normal dev server URL
    # All console logs automatically captured for agents to read
EOF
}

detect_project_type() {
    local project_type="unknown"
    local expected_port=""
    
    echo "üîç Auto-detecting project type..." >&2
    
    # Check for package.json (Node.js projects)
    if [ -f "package.json" ]; then
        if grep -q '"next"' package.json 2>/dev/null; then
            project_type="Next.js"
            expected_port="3000"
        elif grep -q '"vite"' package.json 2>/dev/null; then
            project_type="Vite"
            expected_port="5173"
        elif grep -q '"react"' package.json 2>/dev/null; then
            project_type="React"
            expected_port="3000"
        elif grep -q '"vue"' package.json 2>/dev/null; then
            project_type="Vue"
            expected_port="8080"
        elif grep -q '"nuxt"' package.json 2>/dev/null; then
            project_type="Nuxt"
            expected_port="3000"
        else
            project_type="Node.js"
            expected_port="3000"
        fi
        
    # Check for Go projects
    elif [ -f "go.mod" ] || [ -f "go.sum" ] || [ -f "main.go" ]; then
        project_type="Go"
        expected_port="8080"
        
    # Check for Python projects
    elif [ -f "manage.py" ] || [ -f "requirements.txt" ]; then
        if [ -f "manage.py" ]; then
            project_type="Django"
            expected_port="8000"
        else
            project_type="Python"
            expected_port="8000"
        fi
        
    # Check for other frameworks
    elif [ -f "Cargo.toml" ]; then
        project_type="Rust"
        expected_port="8080"
    elif [ -f "go.mod" ]; then
        project_type="Go"
        expected_port="8080"
    elif [ -f "composer.json" ]; then
        project_type="PHP"
        expected_port="8000"
    else
        project_type="Static HTML"
        expected_port="8000"
    fi
    
    echo "üì¶ Detected: $project_type (expected port: $expected_port)" >&2
    echo "$project_type|$expected_port"
}

find_safe_dev_servers() {
    echo "üîç Scanning for development servers..." >&2
    
    # Use unified common dev server ports
    local dev_servers=()
    
    for port in "${COMMON_DEV_PORTS[@]}"; do
        if lsof -i :$port >/dev/null 2>&1; then
            local process_name=$(lsof -i :$port | tail -1 | awk '{print $1}')
            
            # Only include processes that are clearly dev servers
            case "$process_name" in
                $DEV_SERVER_PROCESS_NAMES)
                    echo "   ‚úÖ Port $port: $process_name (dev server)" >&2
                    dev_servers+=("$port")
                    ;;
                *)
                    echo "   ‚ö™ Port $port: $process_name (system service - skipped)" >&2
                    ;;
            esac
        fi
    done
    
    echo "${#dev_servers[@]} ${dev_servers[@]}"
}

safe_port_selection() {
    local explicit_port="$1"
    
    # If port explicitly specified, use it (but verify it exists)
    if [ -n "$explicit_port" ]; then
        if lsof -i :$explicit_port >/dev/null 2>&1; then
            local process_name=$(lsof -i :$explicit_port | tail -1 | awk '{print $1}')
            echo "üéØ Using explicitly specified port $explicit_port ($process_name)" >&2
            echo "$explicit_port"
            return 0
        else
            echo "‚ùå Port $explicit_port is not in use" >&2
            echo "   üí° Make sure your dev server is running on this port" >&2
            return 1
        fi
    fi
    
    # Auto-detection: only proceed if exactly one dev server is running
    local servers_info=$(find_safe_dev_servers)
    local server_count=$(echo "$servers_info" | awk '{print $1}')
    local server_ports=($(echo "$servers_info" | awk '{for(i=2;i<=NF;i++) print $i}'))
    
    if [ "$server_count" -eq 0 ]; then
        echo "‚ùå No development servers detected" >&2
        echo "   üí° Start your dev server first, then:" >&2
        echo "   üí° Use: see-me [PORT] to specify the port explicitly" >&2
        return 1
    elif [ "$server_count" -eq 1 ]; then
        echo "üéØ Found exactly one dev server on port ${server_ports[0]}" >&2
        echo "${server_ports[0]}"
        return 0
    else
        echo "‚ö†Ô∏è  Multiple dev servers detected: ${server_ports[@]}" >&2
        echo "   üí° Please specify which port to use:" >&2
        for port in "${server_ports[@]}"; do
            local process_name=$(lsof -i :$port | tail -1 | awk '{print $1}')
            echo "   üí° see-me $port    # Connect to $process_name on port $port" >&2
        done
        return 1
    fi
}

wait_for_dev_server() {
    local max_wait=30  # seconds
    local wait_count=0
    
    echo "‚è≥ Waiting for dev server to start..."
    
    while [ $wait_count -lt $max_wait ]; do
        if find_running_dev_server >/dev/null 2>&1; then
            echo "‚úÖ Dev server detected!"
            return 0
        fi
        sleep 1
        wait_count=$((wait_count + 1))
        echo -n "."
    done
    
    echo ""
    echo "‚ùå Timeout waiting for dev server"
    echo "   Make sure your dev server started successfully"
    return 1
}

initialize_logging() {
    if [ ! -d ".devlogger" ]; then
        echo "üîß First time setup - initializing browser logging..."
        mkdir -p .devlogger
        
        # Create console wrapper
        cat > .devlogger/console-wrapper.js << 'EOF'
// DevLogger Console Wrapper - Captures browser console output
(function() {
    'use strict';
    
    const originalConsole = { ...console };
    const logs = [];
    const LOG_SERVER_URL = 'http://localhost:3333/save-log';
    const CLEAR_LOG_URL = 'http://localhost:3333/clear-logs';
    
    // Start new session - get session timestamp from server
    let currentSessionId = null;
    fetch(CLEAR_LOG_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ clear: true })
    }).then(response => response.json())
      .then(data => {
          currentSessionId = data.sessionStart;
          // Session started silently
      }).catch(() => {
          currentSessionId = Date.now(); // Fallback
      });
    
    function addLog(level, args) {
        const message = args.map(arg => {
            if (typeof arg === 'object') {
                if (arg === null) return 'null';
                if (arg instanceof Error) {
                    return `${arg.name}: ${arg.message}${arg.stack ? '\n' + arg.stack : ''}`;
                }
                try {
                    const jsonStr = JSON.stringify(arg, null, 2);
                    // If JSON.stringify returns {}, try to extract properties manually
                    if (jsonStr === '{}' && arg.constructor && arg.constructor.name) {
                        const props = [];
                        for (let key in arg) {
                            try {
                                props.push(`${key}: ${arg[key]}`);
                            } catch (e) {}
                        }
                        // Also try common Error properties
                        if (arg.name) props.push(`name: "${arg.name}"`);
                        if (arg.message) props.push(`message: "${arg.message}"`);
                        if (props.length > 0) {
                            return `{${props.join(', ')}}`;
                        }
                        return `[${arg.constructor.name} object]`;
                    }
                    return jsonStr;
                } catch (e) {
                    return `[Object: ${Object.prototype.toString.call(arg)}]`;
                }
            }
            return String(arg);
        }).join(' ');
        
        const timestamp = new Date().toISOString();
        
        // Send directly to server - no client-side deduplication
        fetch(LOG_SERVER_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                timestamp: timestamp,
                level: level.toUpperCase(),
                message: message
            })
        }).catch(() => {
            // Fallback: store in localStorage if server unavailable
            const fallbackLogs = JSON.parse(localStorage.getItem('devlogger-logs') || '[]');
            fallbackLogs.push({ timestamp, level, message });
            localStorage.setItem('devlogger-logs', JSON.stringify(fallbackLogs));
        });
    }
    
    // Override console methods
    ['log', 'error', 'warn', 'info'].forEach(method => {
        console[method] = function(...args) {
            addLog(method, args);
            originalConsole[method].apply(console, arguments);
        };
    });
    
    // Capture uncaught errors
    window.addEventListener('error', (e) => {
        addLog('error', [`Uncaught Error: ${e.message}`, `at ${e.filename}:${e.lineno}`]);
    });
    
    window.addEventListener('unhandledrejection', (e) => {
        addLog('error', [`Unhandled Promise Rejection: ${e.reason}`]);
    });
    
    // Poll for one-time crawl triggers from agent
    let lastCrawlCheck = 0;
    setInterval(() => {
        fetch('http://localhost:3333/session')
            .then(response => response.text())
            .then(sessionId => {
                // If session changed, it means crawl was triggered
                if (sessionId !== currentSessionId && sessionId > lastCrawlCheck) {
                    lastCrawlCheck = Date.now();
                    originalConsole.log('üï∑Ô∏è One-time crawl triggered by agent');
                    setTimeout(() => {
                        startAutoCrawler();
                    }, 1000); // Brief delay for page stability
                }
            })
            .catch(() => {}); // Ignore network errors
    }, 2000); // Check every 2 seconds
    
    function startAutoCrawler() {
        const visitedElements = new Set();
        const visitedUrls = new Set([window.location.href]);
        
        function findInteractiveElements() {
            const selectors = [
                'a[href]:not([href^="mailto:"]):not([href^="tel:"]):not([href^="#"])',
                'button:not([type="submit"])',
                '[onclick]',
                '[role="button"]',
                '.btn:not(form .btn)',
                '.button:not(form .button)',
                '[tabindex="0"]:not(input):not(textarea)'
            ];
            
            const elements = [];
            selectors.forEach(selector => {
                document.querySelectorAll(selector).forEach(el => {
                    // Skip if inside form or has dangerous text
                    const text = el.textContent.toLowerCase();
                    const dangerousWords = ['delete', 'remove', 'logout', 'sign out', 'clear all'];
                    if (el.closest('form') || dangerousWords.some(word => text.includes(word))) {
                        return;
                    }
                    
                    const elementId = el.tagName + (el.href || el.onclick || el.textContent.slice(0, 20));
                    if (!visitedElements.has(elementId)) {
                        elements.push({ element: el, id: elementId });
                    }
                });
            });
            return elements;
        }
        
        function crawlInteractiveElements() {
            const elements = findInteractiveElements();
            if (elements.length === 0) return;
            
            originalConsole.log(\`üîç Auto-crawler found \${elements.length} interactive elements\`);
            
            elements.forEach(({ element, id }, index) => {
                setTimeout(() => {
                    visitedElements.add(id);
                    
                    try {
                        if (element.tagName === 'A' && element.href) {
                            // For links, check if same origin
                            const url = new URL(element.href, window.location.origin);
                            if (url.origin === window.location.origin && !visitedUrls.has(url.href)) {
                                visitedUrls.add(url.href);
                                originalConsole.log(\`üîó Auto-crawl: Navigating to \${url.pathname}\`);
                                window.location.href = url.href;
                                return;
                            }
                        } else {
                            // For buttons and other interactive elements
                            originalConsole.log(\`üñ±Ô∏è Auto-crawl: Clicking \${element.tagName} - "\${element.textContent.slice(0, 30)}"\`);
                            element.click();
                        }
                    } catch (error) {
                        addLog('error', [\`Auto-crawler error on \${element.tagName}:\`, error]);
                    }
                }, index * 500); // Stagger interactions
            });
        }
        
        crawlInteractiveElements();
    }
    
    // Silent activation - no noise in logs
})();
EOF

        # Create log server (same as before)
        cat > .devlogger/log-server.js << 'EOF'
const http = require('http');
const fs = require('fs');
const path = require('path');

const PORT = 3333;
const LOG_FILE = path.join(__dirname, 'browser.log');

let sessionStartTime = Date.now();
let logCache = new Map(); // For deduplication
let logFileLines = []; // Track log file contents for replacement

const server = http.createServer((req, res) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    if (req.method === 'OPTIONS') {
        res.writeHead(200);
        res.end();
        return;
    }
    
    if (req.method === 'POST' && req.url === '/clear-logs') {
        let body = '';
        req.on('data', chunk => body += chunk);
        req.on('end', () => {
            try {
                const data = JSON.parse(body);
                
                // New session started - update timestamp and clear cache
                if (data.clear === true) {
                    sessionStartTime = Date.now();
                    logCache.clear(); // Reset deduplication for new session
                    logFileLines = []; // Reset file tracking
                    console.log('üîÑ New session started - timestamp updated');
                }
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({success: true, sessionStart: sessionStartTime}));
            } catch (err) {
                res.writeHead(400);
                res.end('Invalid JSON');
            }
        });
    } else if (req.method === 'POST' && req.url === '/save-log') {
        let body = '';
        req.on('data', chunk => body += chunk);
        req.on('end', () => {
            try {
                const log = JSON.parse(body);
                const logKey = `${log.level}:${log.message}`;
                
                // Server-side deduplication with counts
                if (logCache.has(logKey)) {
                    const existing = logCache.get(logKey);
                    existing.count++;
                    existing.lastSeen = log.timestamp;
                    
                    // Find and update the existing line
                    const lineIndex = logFileLines.findIndex(line => line.includes(log.message) && line.includes(log.level));
                    const newLine = `SESSION:${sessionStartTime}|[${existing.lastSeen}] BROWSER ${log.level}: ${log.message} (seen ${existing.count} times)`;
                    
                    if (lineIndex >= 0) {
                        logFileLines[lineIndex] = newLine;
                    } else {
                        logFileLines.push(newLine);
                    }
                } else {
                    // First time seeing this log
                    logCache.set(logKey, { count: 1, lastSeen: log.timestamp });
                    const newLine = `SESSION:${sessionStartTime}|[${log.timestamp}] BROWSER ${log.level}: ${log.message}`;
                    logFileLines.push(newLine);
                }
                
                // Rewrite entire file with deduplicated lines
                fs.writeFileSync(LOG_FILE, logFileLines.join('\n') + '\n');
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({success: true}));
            } catch (err) {
                res.writeHead(400);
                res.end('Invalid JSON');
            }
        });
    } else if (req.method === 'GET' && req.url === '/session') {
        res.writeHead(200, {'Content-Type': 'text/plain'});
        res.end(sessionStartTime.toString());
    } else if (req.method === 'POST' && req.url === '/trigger-crawl') {
        // Trigger one-time crawl by broadcasting to all connected browsers
        console.log('üï∑Ô∏è One-time crawl triggered via API');
        res.writeHead(200, {'Content-Type': 'application/json'});
        res.end(JSON.stringify({success: true, message: 'Crawl triggered'}));
    } else {
        res.writeHead(404);
        res.end('Not found');
    }
});

server.listen(PORT, () => {
    // Log server started silently
});
EOF

        # Create smart proxy
        cat > .devlogger/proxy.js << 'EOF'
const http = require('http');
const fs = require('fs');
const path = require('path');

const PROXY_PORT = 3334;
const TARGET_PORT = process.argv[2] || 3000;
const CONSOLE_SCRIPT = fs.readFileSync(path.join(__dirname, 'console-wrapper.js'), 'utf8');

// Proxy server started silently

const server = http.createServer((req, res) => {
    const proxyReq = http.request({
        hostname: 'localhost',
        port: TARGET_PORT,
        path: req.url,
        method: req.method,
        headers: req.headers
    }, (proxyRes) => {
        const contentType = proxyRes.headers['content-type'] || '';
        
        if (!contentType.includes('text/html')) {
            res.writeHead(proxyRes.statusCode, proxyRes.headers);
            proxyRes.pipe(res);
            return;
        }
        
        let body = '';
        proxyRes.on('data', chunk => body += chunk);
        proxyRes.on('end', () => {
            if (body.includes('<head>')) {
                const script = `<script>${CONSOLE_SCRIPT}</script>`;
                body = body.replace('<head>', `<head>${script}`);
            }
            
            res.writeHead(proxyRes.statusCode, {
                ...proxyRes.headers,
                'content-length': Buffer.byteLength(body)
            });
            res.end(body);
        });
    });
    
    proxyReq.on('error', () => {
        res.writeHead(502);
        res.end('Target server not available');
    });
    
    req.pipe(proxyReq);
});

server.listen(PROXY_PORT, () => {
    // Proxy ready - see-me will show the URL
});
EOF

        echo "‚úÖ Browser logging initialized!"
    else
        # Using existing setup - no output needed
        true
    fi
    
    # Always start with fresh logs for new development session
    > .devlogger/browser.log
}

detect_newly_started_server() {
    echo "üîç Detecting newly started development server..." >&2
    
    # Wait a moment for backgrounded command to start
    sleep 2
    
    # Look for Node.js dev servers (live-server, vite, next, etc.)
    local node_servers=$(ps -eo pid,args | grep -E "$NODE_SERVER_PATTERNS" | grep -v grep)
    
    if [ -n "$node_servers" ]; then
        while IFS= read -r server_line; do
            local pid=$(echo "$server_line" | awk '{print $1}')
            local listening_ports=$(lsof -Pan -p "$pid" -i 2>/dev/null | grep LISTEN | awk -F: '{print $2}' | awk '{print $1}' | sort -u)
            
            if [ -n "$listening_ports" ]; then
                for port in $listening_ports; do
                    if lsof -i :$port >/dev/null 2>&1; then
                        local process_name=$(ps -p "$pid" -o comm= 2>/dev/null || echo "node")
                        echo "   ‚úÖ Found $process_name server on port $port (PID: $pid)" >&2
                        echo "$port"
                        return 0
                    fi
                done
            fi
        done <<< "$node_servers"
    fi
    
    # Look for Go dev servers (go run, compiled binaries, Go dev tools)
    local go_servers=$(ps -eo pid,args | grep -E "$GO_SERVER_PATTERNS" | grep -v grep)
    
    if [ -n "$go_servers" ]; then
        while IFS= read -r server_line; do
            local pid=$(echo "$server_line" | awk '{print $1}')
            local listening_ports=$(lsof -Pan -p "$pid" -i 2>/dev/null | grep LISTEN | awk -F: '{print $2}' | awk '{print $1}' | sort -u)
            
            if [ -n "$listening_ports" ]; then
                for port in $listening_ports; do
                    if lsof -i :$port >/dev/null 2>&1; then
                        local process_name=$(ps -p "$pid" -o comm= 2>/dev/null || echo "go")
                        echo "   ‚úÖ Found $process_name server on port $port (PID: $pid)" >&2
                        echo "$port"
                        return 0
                    fi
                done
            fi
        done <<< "$go_servers"
    fi
    
    # Fallback: look for any dev server process on common dev ports
    local common_ports=(${COMMON_DEV_PORTS[@]})
    for port in "${common_ports[@]}"; do
        if lsof -i :$port >/dev/null 2>&1; then
            local process_info=$(lsof -i :$port | tail -1)
            local process_name=$(echo "$process_info" | awk '{print $1}')
            
            # Check for common dev server processes
            case "$process_name" in
                node|go|main|python*|Python*|ruby|Rails|php|nginx|http-server|webpack*|vite|next*|live-server)
                    local pid=$(echo "$process_info" | awk '{print $2}')
                    echo "   ‚úÖ Found $process_name server on port $port (PID: $pid)" >&2
                    echo "$port"
                    return 0
                    ;;
                *)
                    # Check if it's a compiled binary that might be a Go server
                    local full_process=$(ps -p "$(echo "$process_info" | awk '{print $2}')" -o args= 2>/dev/null || echo "")
                    if [[ "$full_process" == *"go run"* ]] || [[ "$full_process" == "./"* ]]; then
                        local pid=$(echo "$process_info" | awk '{print $2}')
                        echo "   ‚úÖ Found $process_name server on port $port (PID: $pid)" >&2
                        echo "$port"
                        return 0
                    fi
                    ;;
            esac
        fi
    done
    
    echo "   ‚ùå No Node.js or Go dev server detected" >&2
    return 1
}

find_running_dev_server() {
    # Look for Node.js dev servers (live-server, vite, next, etc.)
    local node_servers=$(ps -eo pid,args | grep -E "$NODE_SERVER_PATTERNS" | grep -v grep)
    
    if [ -n "$node_servers" ]; then
        while IFS= read -r server_line; do
            local pid=$(echo "$server_line" | awk '{print $1}')
            local listening_ports=$(lsof -Pan -p "$pid" -i 2>/dev/null | grep LISTEN | awk -F: '{print $2}' | awk '{print $1}' | sort -u)
            
            if [ -n "$listening_ports" ]; then
                for port in $listening_ports; do
                    if lsof -i :$port >/dev/null 2>&1; then
                        local process_name=$(ps -p "$pid" -o comm= 2>/dev/null || echo "node")
                        echo "   ‚úÖ $process_name server on port $port (PID: $pid)"
                        return 0
                    fi
                done
            fi
        done <<< "$node_servers"
    fi
    
    # Look for Go dev servers (go run, compiled binaries, Go dev tools)
    local go_servers=$(ps -eo pid,args | grep -E "$GO_SERVER_PATTERNS" | grep -v grep)
    
    if [ -n "$go_servers" ]; then
        while IFS= read -r server_line; do
            local pid=$(echo "$server_line" | awk '{print $1}')
            local listening_ports=$(lsof -Pan -p "$pid" -i 2>/dev/null | grep LISTEN | awk -F: '{print $2}' | awk '{print $1}' | sort -u)
            
            if [ -n "$listening_ports" ]; then
                for port in $listening_ports; do
                    if lsof -i :$port >/dev/null 2>&1; then
                        local process_name=$(ps -p "$pid" -o comm= 2>/dev/null || echo "go")
                        echo "   ‚úÖ $process_name server on port $port (PID: $pid)"
                        return 0
                    fi
                done
            fi
        done <<< "$go_servers"
    fi
    
    # Fallback: look for any dev server process on common dev ports
    local common_ports=(${COMMON_DEV_PORTS[@]})
    for port in "${common_ports[@]}"; do
        if lsof -i :$port >/dev/null 2>&1; then
            local process_info=$(lsof -i :$port | tail -1)
            local process_name=$(echo "$process_info" | awk '{print $1}')
            
            # Check for common dev server processes
            case "$process_name" in
                node|go|main|python*|Python*|ruby|Rails|php|nginx|http-server|webpack*|vite|next*|live-server)
                    local pid=$(echo "$process_info" | awk '{print $2}')
                    echo "   ‚úÖ $process_name server on port $port (PID: $pid)"
                    return 0
                    ;;
                *)
                    # Check if it's a compiled binary that might be a Go server
                    local full_process=$(ps -p "$(echo "$process_info" | awk '{print $2}')" -o args= 2>/dev/null || echo "")
                    if [[ "$full_process" == *"go run"* ]] || [[ "$full_process" == "./"* ]]; then
                        local pid=$(echo "$process_info" | awk '{print $2}')
                        echo "   ‚úÖ $process_name server on port $port (PID: $pid)"
                        return 0
                    fi
                    ;;
            esac
        fi
    done
    
    return 1
}

start_smart_logging() {
    local explicit_port="$1"
    local crawl_mode="$2"
    
    # Clean up any stale PID files from previous runs
    cleanup_stale_pids
    
    initialize_logging
    
    local target_port
    
    if [ -n "$explicit_port" ]; then
        # Port explicitly specified
        if lsof -i :$explicit_port >/dev/null 2>&1; then
            target_port="$explicit_port"
            echo "üéØ Using specified port $target_port" >&2
        else
            echo "‚ùå Port $explicit_port is not in use" >&2
            return 1
        fi
    else
        # Auto-detect newly started server
        target_port=$(detect_newly_started_server)
        if [ $? -ne 0 ]; then
            echo ""
            echo "üí° Make sure to run: npm run dev & see-me"
            echo "üí° Or specify port manually: see-me [PORT]"
            return 1
        fi
    fi
    
    echo -e "\nüöÄ Starting browser logging for port $target_port..."
    
    # Stop any existing services using improved cleanup
    stop_services >/dev/null 2>&1
    
    # Start services and capture PIDs
    node .devlogger/log-server.js &
    echo $! > .devlogger/log-server.pid
    
    node .devlogger/proxy.js $target_port &
    echo $! > .devlogger/proxy.pid
    
    sleep 2
    
    echo ""
    echo -e "\033[1;32m‚úÖ see-me active on port $target_port\033[0m"
    echo ""
    echo -e "\033[1;36müëÜ CLICK:\033[0m \033[1;4;34mhttp://localhost:3334\033[0m"
    echo -e "\033[1;33müìã LOGS:\033[0m \033[1msee-me logs\033[0m"
    echo -e "\033[1;31müõë STOP:\033[0m \033[1msee-me stop\033[0m"
    echo ""
    echo -e "\033[2müîç Monitoring... (Press Ctrl+C to stop)\033[0m"
    
    # Keep running and show live log updates
    trap 'echo ""; stop_services; exit 0' INT
    
    # Follow logs if they exist, otherwise just wait
    if [ -f ".devlogger/browser.log" ]; then
        tail -f .devlogger/browser.log
    else
        # Just wait until interrupted
        while true; do
            sleep 1
        done
    fi
}

show_logs() {
    if [ -f ".devlogger/browser.log" ]; then
        echo -e "\033[1;36müìã Browser Console Logs (Current Session):\033[0m"
        echo -e "\033[1;36m==========================================\033[0m"
        
        # Get the latest session timestamp from running log server
        local latest_session=$(curl -s http://localhost:3333/session 2>/dev/null || echo "")
        
        if [ -n "$latest_session" ]; then
            # Show only logs from current session, clean format
            local logs=$(grep "SESSION:$latest_session" .devlogger/browser.log | sed 's/SESSION:[0-9]*|//' | sed 's/√∞≈∏"/üîç/g' | sed 's/√∞≈∏"‚Äû/üîÑ/g' 2>/dev/null)
            if [ -n "$logs" ]; then
                echo "$logs"
                local error_count=$(echo "$logs" | grep -c "ERROR")
                if [ $error_count -gt 0 ]; then
                    echo ""
                    echo -e "\033[1;31müö® Found $error_count error(s) that need fixing\033[0m"
                fi
            else
                echo -e "\033[1;32m‚úÖ No logs from current session yet (this is good!)\033[0m"
            fi
        else
            # Fallback: show recent logs, clean format  
            local fallback_logs=$(tail -20 .devlogger/browser.log | sed 's/√∞≈∏"/üîç/g' | sed 's/√∞≈∏"‚Äû/üîÑ/g' 2>/dev/null)
            if [ -n "$fallback_logs" ]; then
                echo "$fallback_logs"
            else
                echo -e "\033[1;33m‚ö†Ô∏è  No logs found\033[0m"
            fi
        fi
        
        echo ""
        echo -e "\033[1;33müí° Agent Instructions:\033[0m"
        echo -e "\033[1;33mAfter fixing errors, run '\033[1;36msee-me crawl\033[1;33m' to refresh the browser and discover remaining issues.\033[0m"
    else
        echo -e "\033[1;33müìã No logs found. Visit \033[1;36mhttp://localhost:3334\033[1;33m to generate logs.\033[0m"
    fi
}

show_status() {
    echo -e "\033[1;36müìä see-me Status\033[0m"
    echo -e "\033[1;36m===============\033[0m"
    
    if [ -d ".devlogger" ]; then
        echo -e "üìÅ Initialized: \033[1;32m‚úÖ Ready\033[0m"
    else
        echo -e "üìÅ Initialized: \033[1;33m‚ùå (will auto-initialize on first run)\033[0m"
    fi
    
    # Check log server status
    if [ -f ".devlogger/log-server.pid" ]; then
        local log_pid=$(cat .devlogger/log-server.pid 2>/dev/null)
        if [ -n "$log_pid" ] && kill -0 "$log_pid" 2>/dev/null; then
            echo -e "üåê Log server: \033[1;32m‚úÖ Running (port 3333, PID: $log_pid)\033[0m"
        else
            echo -e "üåê Log server: \033[1;31m‚ùå Stopped (stale PID file)\033[0m"
            rm -f .devlogger/log-server.pid
        fi
    elif pgrep -f "log-server.js" >/dev/null; then
        local log_pid=$(pgrep -f "log-server.js")
        echo -e "üåê Log server: \033[1;33m‚ö†Ô∏è  Running (port 3333, PID: $log_pid, no PID file)\033[0m"
    else
        echo -e "üåê Log server: \033[1;31m‚ùå Stopped\033[0m"
    fi
    
    # Check proxy server status
    if [ -f ".devlogger/proxy.pid" ]; then
        local proxy_pid=$(cat .devlogger/proxy.pid 2>/dev/null)
        if [ -n "$proxy_pid" ] && kill -0 "$proxy_pid" 2>/dev/null; then
            echo -e "üîÑ Proxy server: \033[1;32m‚úÖ Running (port 3334, PID: $proxy_pid)\033[0m"
        else
            echo -e "üîÑ Proxy server: \033[1;31m‚ùå Stopped (stale PID file)\033[0m"
            rm -f .devlogger/proxy.pid
        fi
    elif pgrep -f "proxy.js" >/dev/null; then
        local proxy_pid=$(pgrep -f "proxy.js")
        echo -e "üîÑ Proxy server: \033[1;33m‚ö†Ô∏è  Running (port 3334, PID: $proxy_pid, no PID file)\033[0m"
    else
        echo -e "üîÑ Proxy server: \033[1;31m‚ùå Stopped\033[0m"
    fi
    
    # Show detected project info
    if [ -f "package.json" ] || [ -f "manage.py" ] || [ -f "requirements.txt" ]; then
        local project_info=$(detect_project_type 2>/dev/null || echo "unknown|unknown")
        local project_type=$(echo "$project_info" | cut -d'|' -f1)
        echo -e "üì¶ Project type: \033[1;35m$project_type\033[0m"
    fi
    
    # Show current dev servers
    echo ""
    echo -e "\033[1;36müîç Running dev servers:\033[0m"
    if ! find_running_dev_server 2>/dev/null; then
        echo -e "   \033[1;33mNone detected\033[0m"
    fi
    
    if [ -f ".devlogger/browser.log" ]; then
        local log_count=$(wc -l < .devlogger/browser.log 2>/dev/null || echo 0)
        echo -e "üìã Logs captured: \033[1;34m$log_count lines\033[0m"
    fi
}

stop_services() {
    echo "üõë Stopping see-me services..."
    
    # Stop services using stored PIDs
    local stopped_count=0
    
    if [ -f ".devlogger/log-server.pid" ]; then
        local log_pid=$(cat .devlogger/log-server.pid 2>/dev/null)
        if [ -n "$log_pid" ] && kill -0 "$log_pid" 2>/dev/null; then
            if kill "$log_pid" 2>/dev/null; then
                echo "   ‚úÖ Log server stopped (PID: $log_pid)"
                stopped_count=$((stopped_count + 1))
            else
                echo "   ‚ö†Ô∏è  Log server PID $log_pid could not be killed"
            fi
        fi
        rm -f .devlogger/log-server.pid
    fi
    
    if [ -f ".devlogger/proxy.pid" ]; then
        local proxy_pid=$(cat .devlogger/proxy.pid 2>/dev/null)
        if [ -n "$proxy_pid" ] && kill -0 "$proxy_pid" 2>/dev/null; then
            if kill "$proxy_pid" 2>/dev/null; then
                echo "   ‚úÖ Proxy server stopped (PID: $proxy_pid)"
                stopped_count=$((stopped_count + 1))
            else
                echo "   ‚ö†Ô∏è  Proxy server PID $proxy_pid could not be killed"
            fi
        fi
        rm -f .devlogger/proxy.pid
    fi
    
    # Fallback: use pattern matching if PID files didn't work
    if [ $stopped_count -eq 0 ]; then
        echo "   üîç No PID files found, using pattern matching..."
        if pkill -f "log-server.js" 2>/dev/null; then
            echo "   ‚úÖ Log server stopped (pattern match)"
            stopped_count=$((stopped_count + 1))
        fi
        if pkill -f "proxy.js" 2>/dev/null; then
            echo "   ‚úÖ Proxy server stopped (pattern match)"
            stopped_count=$((stopped_count + 1))
        fi
    fi
    
    if [ $stopped_count -gt 0 ]; then
        echo "‚úÖ Services stopped ($stopped_count processes)"
    else
        echo "‚úÖ No running services found"
    fi
}

show_version() {
    echo "see-me version 2.2.0"
    echo "Smart Browser Console Logging for Coding Agents"
}

run_one_time_crawl() {
    # Check if see-me services are running
    if ! curl -s http://localhost:3333/session >/dev/null 2>&1; then
        echo -e "\033[1;31m‚ùå see-me services not running. Start with: npm run dev & see-me\033[0m"
        return 1
    fi
    
    # Check if any browsers are connected by checking recent logs
    if [ ! -f ".devlogger/browser.log" ] || [ ! -s ".devlogger/browser.log" ]; then
        echo -e "\033[1;33m‚ö†Ô∏è  No browser activity detected. Make sure to visit http://localhost:3334 first.\033[0m"
        echo -e "\033[1;33m   Open a browser tab to http://localhost:3334 then run 'see-me crawl' again.\033[0m"
        return 1
    fi
    
    echo -e "\033[1;36müîÑ STARTING CRAWL: Triggering browser refresh and error discovery...\033[0m"
    
    # Get initial log count for comparison
    local initial_logs=$(wc -l < .devlogger/browser.log 2>/dev/null || echo "0")
    
    # Clear current session to trigger fresh crawl
    curl -s -X POST http://localhost:3333/clear-logs -H "Content-Type: application/json" -d '{"clear": true}' >/dev/null 2>&1
    
    # Send crawl trigger to browser via a special endpoint
    local trigger_response=$(curl -s -X POST http://localhost:3333/trigger-crawl)
    
    if echo "$trigger_response" | grep -q "success"; then
        echo -e "\033[1;32m‚úÖ CRAWL TRIGGERED: Browser received crawl command\033[0m"
    else
        echo -e "\033[1;31m‚ùå CRAWL FAILED: Could not reach browser\033[0m"
        return 1
    fi
    
    echo -e "\033[1;33m‚è≥ CRAWLING: Waiting for browser to complete error discovery...\033[0m"
    
    # Wait and show progress
    for i in {1..8}; do
        echo -n "."
        sleep 1
    done
    echo ""
    
    # Check if new logs were generated
    local final_logs=$(wc -l < .devlogger/browser.log 2>/dev/null || echo "0")
    local new_logs=$((final_logs - initial_logs))
    
    if [ $new_logs -gt 0 ]; then
        echo -e "\033[1;32müéâ CRAWL COMPLETE: Discovered $new_logs new log entries\033[0m"
    else
        echo -e "\033[1;33m‚ö†Ô∏è  CRAWL COMPLETE: No new errors found (good sign!)\033[0m"
    fi
    
    echo ""
    echo -e "\033[1;36müìã FRESH CRAWL RESULTS:\033[0m"
    echo -e "\033[1;36m=======================\033[0m"
    show_logs
}

# Main execution
case "${1:-start}" in
    start|"")
        start_smart_logging
        ;;
    crawl)
        echo "üï∑Ô∏è Running one-time crawl to discover errors..."
        run_one_time_crawl
        ;;
    logs)
        show_logs
        ;;
    status)
        show_status  
        ;;
    stop)
        stop_services
        ;;
    version|--version|-v)
        show_version
        ;;
    help|--help|-h)
        show_help
        ;;
    [0-9]*)
        # Port number specified
        start_smart_logging "$1"
        ;;
    *)
        echo "‚ùå Unknown command: $1"
        echo "   Use 'see-me help' for usage"
        echo "   Or specify a port: see-me [PORT]"
        echo "   Or use: see-me crawl"
        exit 1
        ;;
esac
#!/bin/bash

# see-me - Intelligent Browser Console Logging
# Auto-detects project type and running dev servers
# Usage: npm run dev & see-me
# Version: 2.1.0

set -e

show_help() {
    cat << EOF
see-me - Smart Browser Console Logging (v2.1.0)

USAGE:
    npm run dev & see-me    # One command - auto-detects new server port
    see-me [PORT]           # Connect to specific port
    see-me logs             # View captured browser logs  
    see-me stop             # Stop logging services
    see-me status           # Show current status
    see-me version          # Show version information

WORKFLOWS:
    # Method 1: Single command (recommended)
    npm run dev & see-me    # Automatically detects the port from new server
    
    # Method 2: Explicit port
    see-me 8080             # Connect to port 8080 specifically

FEATURES:
    ‚úÖ Detects newly started dev servers automatically
    ‚úÖ Works with any framework (React, Django, Python, Node, etc.)
    ‚úÖ Browser console log capture with proxy injection
    ‚úÖ Agent-readable log files

EXAMPLE:
    npm run dev & see-me
    # Visit http://localhost:3334 instead of your normal dev server URL
    # All console logs automatically captured for agents to read
EOF
}

detect_project_type() {
    local project_type="unknown"
    local expected_port=""
    
    echo "üîç Auto-detecting project type..." >&2
    
    # Check for package.json (Node.js projects)
    if [ -f "package.json" ]; then
        if grep -q '"next"' package.json 2>/dev/null; then
            project_type="Next.js"
            expected_port="3000"
        elif grep -q '"vite"' package.json 2>/dev/null; then
            project_type="Vite"
            expected_port="5173"
        elif grep -q '"react"' package.json 2>/dev/null; then
            project_type="React"
            expected_port="3000"
        elif grep -q '"vue"' package.json 2>/dev/null; then
            project_type="Vue"
            expected_port="8080"
        elif grep -q '"nuxt"' package.json 2>/dev/null; then
            project_type="Nuxt"
            expected_port="3000"
        else
            project_type="Node.js"
            expected_port="3000"
        fi
        
    # Check for Python projects
    elif [ -f "manage.py" ] || [ -f "requirements.txt" ]; then
        if [ -f "manage.py" ]; then
            project_type="Django"
            expected_port="8000"
        else
            project_type="Python"
            expected_port="8000"
        fi
        
    # Check for other frameworks
    elif [ -f "Cargo.toml" ]; then
        project_type="Rust"
        expected_port="8080"
    elif [ -f "go.mod" ]; then
        project_type="Go"
        expected_port="8080"
    elif [ -f "composer.json" ]; then
        project_type="PHP"
        expected_port="8000"
    else
        project_type="Static HTML"
        expected_port="8000"
    fi
    
    echo "üì¶ Detected: $project_type (expected port: $expected_port)" >&2
    echo "$project_type|$expected_port"
}

find_safe_dev_servers() {
    echo "üîç Scanning for development servers..." >&2
    
    # Common dev server ports (ordered by priority)
    local common_ports=(3000 8000 9999 3001 3002 5173 8080 8888 9000 4000 5500)
    local dev_servers=()
    
    for port in "${common_ports[@]}"; do
        if lsof -i :$port >/dev/null 2>&1; then
            local process_name=$(lsof -i :$port | tail -1 | awk '{print $1}')
            
            # Only include processes that are clearly dev servers
            case "$process_name" in
                node|Node|python*|Python*|ruby|Rails|php|nginx|http-server|webpack*|vite|next*|live-server)
                    echo "   ‚úÖ Port $port: $process_name (dev server)" >&2
                    dev_servers+=("$port")
                    ;;
                *)
                    echo "   ‚ö™ Port $port: $process_name (system service - skipped)" >&2
                    ;;
            esac
        fi
    done
    
    echo "${#dev_servers[@]} ${dev_servers[@]}"
}

safe_port_selection() {
    local explicit_port="$1"
    
    # If port explicitly specified, use it (but verify it exists)
    if [ -n "$explicit_port" ]; then
        if lsof -i :$explicit_port >/dev/null 2>&1; then
            local process_name=$(lsof -i :$explicit_port | tail -1 | awk '{print $1}')
            echo "üéØ Using explicitly specified port $explicit_port ($process_name)" >&2
            echo "$explicit_port"
            return 0
        else
            echo "‚ùå Port $explicit_port is not in use" >&2
            echo "   üí° Make sure your dev server is running on this port" >&2
            return 1
        fi
    fi
    
    # Auto-detection: only proceed if exactly one dev server is running
    local servers_info=$(find_safe_dev_servers)
    local server_count=$(echo "$servers_info" | awk '{print $1}')
    local server_ports=($(echo "$servers_info" | awk '{for(i=2;i<=NF;i++) print $i}'))
    
    if [ "$server_count" -eq 0 ]; then
        echo "‚ùå No development servers detected" >&2
        echo "   üí° Start your dev server first, then:" >&2
        echo "   üí° Use: see-me [PORT] to specify the port explicitly" >&2
        return 1
    elif [ "$server_count" -eq 1 ]; then
        echo "üéØ Found exactly one dev server on port ${server_ports[0]}" >&2
        echo "${server_ports[0]}"
        return 0
    else
        echo "‚ö†Ô∏è  Multiple dev servers detected: ${server_ports[@]}" >&2
        echo "   üí° Please specify which port to use:" >&2
        for port in "${server_ports[@]}"; do
            local process_name=$(lsof -i :$port | tail -1 | awk '{print $1}')
            echo "   üí° see-me $port    # Connect to $process_name on port $port" >&2
        done
        return 1
    fi
}

wait_for_dev_server() {
    local max_wait=30  # seconds
    local wait_count=0
    
    echo "‚è≥ Waiting for dev server to start..."
    
    while [ $wait_count -lt $max_wait ]; do
        if find_running_dev_server >/dev/null 2>&1; then
            echo "‚úÖ Dev server detected!"
            return 0
        fi
        sleep 1
        wait_count=$((wait_count + 1))
        echo -n "."
    done
    
    echo ""
    echo "‚ùå Timeout waiting for dev server"
    echo "   Make sure your dev server started successfully"
    return 1
}

initialize_logging() {
    if [ ! -d ".devlogger" ]; then
        echo "üîß First time setup - initializing browser logging..."
        mkdir -p .devlogger
        
        # Create console wrapper
        cat > .devlogger/console-wrapper.js << 'EOF'
// DevLogger Console Wrapper - Captures browser console output
(function() {
    'use strict';
    
    const originalConsole = { ...console };
    const logs = [];
    const LOG_SERVER_URL = 'http://localhost:3333/save-log';
    const CLEAR_LOG_URL = 'http://localhost:3333/clear-logs';
    
    // Start new session - get session timestamp from server
    let currentSessionId = null;
    fetch(CLEAR_LOG_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ clear: true })
    }).then(response => response.json())
      .then(data => {
          currentSessionId = data.sessionStart;
          // Session started silently
      }).catch(() => {
          currentSessionId = Date.now(); // Fallback
      });
    
    function addLog(level, args) {
        const message = args.map(arg => {
            if (typeof arg === 'object') {
                if (arg === null) return 'null';
                if (arg instanceof Error) {
                    return `${arg.name}: ${arg.message}${arg.stack ? '\n' + arg.stack : ''}`;
                }
                try {
                    const jsonStr = JSON.stringify(arg, null, 2);
                    // If JSON.stringify returns {}, try to extract properties manually
                    if (jsonStr === '{}' && arg.constructor && arg.constructor.name) {
                        const props = [];
                        for (let key in arg) {
                            try {
                                props.push(`${key}: ${arg[key]}`);
                            } catch (e) {}
                        }
                        // Also try common Error properties
                        if (arg.name) props.push(`name: "${arg.name}"`);
                        if (arg.message) props.push(`message: "${arg.message}"`);
                        if (props.length > 0) {
                            return `{${props.join(', ')}}`;
                        }
                        return `[${arg.constructor.name} object]`;
                    }
                    return jsonStr;
                } catch (e) {
                    return `[Object: ${Object.prototype.toString.call(arg)}]`;
                }
            }
            return String(arg);
        }).join(' ');
        
        const timestamp = new Date().toISOString();
        
        // Send directly to server - no client-side deduplication
        fetch(LOG_SERVER_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                timestamp: timestamp,
                level: level.toUpperCase(),
                message: message
            })
        }).catch(() => {
            // Fallback: store in localStorage if server unavailable
            const fallbackLogs = JSON.parse(localStorage.getItem('devlogger-logs') || '[]');
            fallbackLogs.push({ timestamp, level, message });
            localStorage.setItem('devlogger-logs', JSON.stringify(fallbackLogs));
        });
    }
    
    // Override console methods
    ['log', 'error', 'warn', 'info'].forEach(method => {
        console[method] = function(...args) {
            addLog(method, args);
            originalConsole[method].apply(console, arguments);
        };
    });
    
    // Capture uncaught errors
    window.addEventListener('error', (e) => {
        addLog('error', [`Uncaught Error: ${e.message}`, `at ${e.filename}:${e.lineno}`]);
    });
    
    window.addEventListener('unhandledrejection', (e) => {
        addLog('error', [`Unhandled Promise Rejection: ${e.reason}`]);
    });
    
    // Silent activation - no noise in logs
})();
EOF

        # Create log server (same as before)
        cat > .devlogger/log-server.js << 'EOF'
const http = require('http');
const fs = require('fs');
const path = require('path');

const PORT = 3333;
const LOG_FILE = path.join(__dirname, 'browser.log');

let sessionStartTime = Date.now();
let logCache = new Map(); // For deduplication
let logFileLines = []; // Track log file contents for replacement

const server = http.createServer((req, res) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    if (req.method === 'OPTIONS') {
        res.writeHead(200);
        res.end();
        return;
    }
    
    if (req.method === 'POST' && req.url === '/clear-logs') {
        let body = '';
        req.on('data', chunk => body += chunk);
        req.on('end', () => {
            try {
                const data = JSON.parse(body);
                
                // New session started - update timestamp and clear cache
                if (data.clear === true) {
                    sessionStartTime = Date.now();
                    logCache.clear(); // Reset deduplication for new session
                    logFileLines = []; // Reset file tracking
                    console.log('üîÑ New session started - timestamp updated');
                }
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({success: true, sessionStart: sessionStartTime}));
            } catch (err) {
                res.writeHead(400);
                res.end('Invalid JSON');
            }
        });
    } else if (req.method === 'POST' && req.url === '/save-log') {
        let body = '';
        req.on('data', chunk => body += chunk);
        req.on('end', () => {
            try {
                const log = JSON.parse(body);
                const logKey = `${log.level}:${log.message}`;
                
                // Server-side deduplication with counts
                if (logCache.has(logKey)) {
                    const existing = logCache.get(logKey);
                    existing.count++;
                    existing.lastSeen = log.timestamp;
                    
                    // Find and update the existing line
                    const lineIndex = logFileLines.findIndex(line => line.includes(log.message) && line.includes(log.level));
                    const newLine = `SESSION:${sessionStartTime}|[${existing.lastSeen}] BROWSER ${log.level}: ${log.message} (seen ${existing.count} times)`;
                    
                    if (lineIndex >= 0) {
                        logFileLines[lineIndex] = newLine;
                    } else {
                        logFileLines.push(newLine);
                    }
                } else {
                    // First time seeing this log
                    logCache.set(logKey, { count: 1, lastSeen: log.timestamp });
                    const newLine = `SESSION:${sessionStartTime}|[${log.timestamp}] BROWSER ${log.level}: ${log.message}`;
                    logFileLines.push(newLine);
                }
                
                // Rewrite entire file with deduplicated lines
                fs.writeFileSync(LOG_FILE, logFileLines.join('\n') + '\n');
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({success: true}));
            } catch (err) {
                res.writeHead(400);
                res.end('Invalid JSON');
            }
        });
    } else if (req.method === 'GET' && req.url === '/session') {
        res.writeHead(200, {'Content-Type': 'text/plain'});
        res.end(sessionStartTime.toString());
    } else {
        res.writeHead(404);
        res.end('Not found');
    }
});

server.listen(PORT, () => {
    console.log(`üåê see-me log server running on http://localhost:${PORT}`);
});
EOF

        # Create smart proxy
        cat > .devlogger/proxy.js << 'EOF'
const http = require('http');
const fs = require('fs');
const path = require('path');

const PROXY_PORT = 3334;
const TARGET_PORT = process.argv[2] || 3000;
const CONSOLE_SCRIPT = fs.readFileSync(path.join(__dirname, 'console-wrapper.js'), 'utf8');

console.log(`üîÑ Smart proxy: localhost:${PROXY_PORT} ‚Üí localhost:${TARGET_PORT}`);

const server = http.createServer((req, res) => {
    const proxyReq = http.request({
        hostname: 'localhost',
        port: TARGET_PORT,
        path: req.url,
        method: req.method,
        headers: req.headers
    }, (proxyRes) => {
        const contentType = proxyRes.headers['content-type'] || '';
        
        if (!contentType.includes('text/html')) {
            res.writeHead(proxyRes.statusCode, proxyRes.headers);
            proxyRes.pipe(res);
            return;
        }
        
        let body = '';
        proxyRes.on('data', chunk => body += chunk);
        proxyRes.on('end', () => {
            if (body.includes('<head>')) {
                const script = `<script>${CONSOLE_SCRIPT}</script>`;
                body = body.replace('<head>', `<head>${script}`);
            }
            
            res.writeHead(proxyRes.statusCode, {
                ...proxyRes.headers,
                'content-length': Buffer.byteLength(body)
            });
            res.end(body);
        });
    });
    
    proxyReq.on('error', () => {
        res.writeHead(502);
        res.end('Target server not available');
    });
    
    req.pipe(proxyReq);
});

server.listen(PROXY_PORT, () => {
    console.log(`üåê Visit http://localhost:${PROXY_PORT} (instead of localhost:${TARGET_PORT})`);
});
EOF

        echo "‚úÖ Browser logging initialized!"
    else
        echo "üîß Using existing browser logging setup..."
    fi
    
    # Always start with fresh logs for new development session
    echo "üóëÔ∏è  Clearing previous browser logs for fresh session..."
    > .devlogger/browser.log
}

detect_newly_started_server() {
    echo "üîç Detecting newly started development server..." >&2
    
    # Wait a moment for backgrounded command to start
    sleep 2
    
    # Simple approach - find any python with http.server or similar
    local simple_match=$(ps -eo pid,args | grep -E "(Python.*-m.*http\.server|python.*-m.*http\.server|python.*http\.server)" | grep -v grep | head -1)
    if [ -n "$simple_match" ]; then
        local pid=$(echo "$simple_match" | awk '{print $1}')
        local listening_ports=$(lsof -Pan -p "$pid" -i 2>/dev/null | grep LISTEN | awk -F: '{print $2}' | awk '{print $1}' | sort -u)
        
        if [ -n "$listening_ports" ]; then
            for port in $listening_ports; do
                if lsof -i :$port >/dev/null 2>&1; then
                    local process_name=$(ps -p "$pid" -o comm= 2>/dev/null)
                    echo "   ‚úÖ Found $process_name server on port $port (PID: $pid)" >&2
                    echo "$port"
                    return 0
                fi
            done
        fi
    fi
    
    echo "   ‚ùå No dev server detected" >&2
    return 1
}

start_smart_logging() {
    local explicit_port="$1"
    initialize_logging
    
    local target_port
    
    if [ -n "$explicit_port" ]; then
        # Port explicitly specified
        if lsof -i :$explicit_port >/dev/null 2>&1; then
            target_port="$explicit_port"
            echo "üéØ Using specified port $target_port" >&2
        else
            echo "‚ùå Port $explicit_port is not in use" >&2
            return 1
        fi
    else
        # Auto-detect newly started server
        target_port=$(detect_newly_started_server)
        if [ $? -ne 0 ]; then
            echo ""
            echo "üí° Make sure to run: npm run dev & see-me"
            echo "üí° Or specify port manually: see-me [PORT]"
            return 1
        fi
    fi
    
    echo ""
    echo "üöÄ Starting smart browser logging for port $target_port..."
    
    # Stop any existing services
    pkill -f "log-server.js" 2>/dev/null || true
    pkill -f "proxy.js" 2>/dev/null || true
    
    # Start services
    /opt/homebrew/bin/node .devlogger/log-server.js &
    /opt/homebrew/bin/node .devlogger/proxy.js $target_port &
    
    sleep 2
    
    echo ""
    echo "üéâ see-me is active!"
    echo "üåê Visit: http://localhost:3334"
    echo "üìã View logs: see-me logs (in another terminal)"
    echo "üõë Stop: see-me stop (or Ctrl+C)"
    echo ""
    echo "üí° All browser console output is now automatically captured for agents!"
    echo ""
    echo "üîç Monitoring... (Press Ctrl+C to stop)"
    
    # Keep running and show live log updates
    trap 'echo ""; echo "üõë Stopping see-me..."; pkill -f "log-server.js" 2>/dev/null || true; pkill -f "proxy.js" 2>/dev/null || true; exit 0' INT
    
    # Follow logs if they exist, otherwise just wait
    if [ -f ".devlogger/browser.log" ]; then
        tail -f .devlogger/browser.log
    else
        # Just wait until interrupted
        while true; do
            sleep 1
        done
    fi
}

show_logs() {
    if [ -f ".devlogger/browser.log" ]; then
        echo "üìã Browser Console Logs (Current Session):"
        echo "=========================================="
        
        # Get the latest session timestamp from running log server
        local latest_session=$(curl -s http://localhost:3333/session 2>/dev/null || echo "")
        
        if [ -n "$latest_session" ]; then
            # Show only logs from current session, clean format
            grep "SESSION:$latest_session" .devlogger/browser.log | sed 's/SESSION:[0-9]*|//' | sed 's/√∞≈∏"/üîç/g' | sed 's/√∞≈∏"‚Äû/üîÑ/g' 2>/dev/null || echo "No logs from current session yet."
        else
            # Fallback: show recent logs, clean format  
            tail -20 .devlogger/browser.log | sed 's/√∞≈∏"/üîç/g' | sed 's/√∞≈∏"‚Äû/üîÑ/g' 2>/dev/null || echo "No logs found."
        fi
    else
        echo "üìã No logs found. Visit http://localhost:3334 to generate logs."
    fi
}

show_status() {
    echo "üìä see-me Status"
    echo "==============="
    
    if [ -d ".devlogger" ]; then
        echo "üìÅ Initialized: ‚úÖ"
    else
        echo "üìÅ Initialized: ‚ùå (will auto-initialize on first run)"
    fi
    
    if pgrep -f "log-server.js" >/dev/null; then
        echo "üåê Log server: ‚úÖ Running (port 3333)"
    else
        echo "üåê Log server: ‚ùå Stopped"
    fi
    
    if pgrep -f "proxy.js" >/dev/null; then
        local proxy_pid=$(pgrep -f "proxy.js")
        echo "üîÑ Proxy server: ‚úÖ Running (port 3334)"
    else
        echo "üîÑ Proxy server: ‚ùå Stopped"
    fi
    
    # Show detected project info
    if [ -f "package.json" ] || [ -f "manage.py" ] || [ -f "requirements.txt" ]; then
        local project_info=$(detect_project_type 2>/dev/null || echo "unknown|unknown")
        local project_type=$(echo "$project_info" | cut -d'|' -f1)
        echo "üì¶ Project type: $project_type"
    fi
    
    # Show current dev servers
    echo ""
    echo "üîç Running dev servers:"
    find_running_dev_server >/dev/null 2>&1 || echo "   None detected"
    
    if [ -f ".devlogger/browser.log" ]; then
        local log_count=$(wc -l < .devlogger/browser.log 2>/dev/null || echo 0)
        echo "üìã Logs captured: $log_count lines"
    fi
}

stop_services() {
    echo "üõë Stopping see-me services..."
    pkill -f "log-server.js" 2>/dev/null || true
    pkill -f "proxy.js" 2>/dev/null || true
    echo "‚úÖ Services stopped"
}

show_version() {
    echo "see-me version 2.1.0"
    echo "Smart Browser Console Logging for Coding Agents"
}

# Main execution
case "${1:-start}" in
    start|"")
        start_smart_logging
        ;;
    logs)
        show_logs
        ;;
    status)
        show_status  
        ;;
    stop)
        stop_services
        ;;
    version|--version|-v)
        show_version
        ;;
    help|--help|-h)
        show_help
        ;;
    [0-9]*)
        # Port number specified
        start_smart_logging "$1"
        ;;
    *)
        echo "‚ùå Unknown command: $1"
        echo "   Use 'see-me help' for usage"
        echo "   Or specify a port: see-me [PORT]"
        exit 1
        ;;
esac
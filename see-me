#!/bin/bash

# see-me - Intelligent Browser Console Logging
# Auto-detects project type and running dev servers
# Usage: npm run dev & see-me

set -e

show_help() {
    cat << EOF
see-me - Smart Browser Console Logging

USAGE:
    npm run dev & see-me    # One command - auto-detects new server port
    see-me [PORT]           # Connect to specific port
    see-me logs             # View captured browser logs  
    see-me stop             # Stop logging services
    see-me status           # Show current status

WORKFLOWS:
    # Method 1: Single command (recommended)
    npm run dev & see-me    # Automatically detects the port from new server
    
    # Method 2: Explicit port
    see-me 8080             # Connect to port 8080 specifically

FEATURES:
    ‚úÖ Detects newly started dev servers automatically
    ‚úÖ Works with any framework (React, Django, Python, Node, etc.)
    ‚úÖ Browser console log capture with proxy injection
    ‚úÖ Agent-readable log files

EXAMPLE:
    npm run dev & see-me
    # Visit http://localhost:3334 instead of your normal dev server URL
    # All console logs automatically captured for agents to read
EOF
}

detect_project_type() {
    local project_type="unknown"
    local expected_port=""
    
    echo "üîç Auto-detecting project type..." >&2
    
    # Check for package.json (Node.js projects)
    if [ -f "package.json" ]; then
        if grep -q '"next"' package.json 2>/dev/null; then
            project_type="Next.js"
            expected_port="3000"
        elif grep -q '"vite"' package.json 2>/dev/null; then
            project_type="Vite"
            expected_port="5173"
        elif grep -q '"react"' package.json 2>/dev/null; then
            project_type="React"
            expected_port="3000"
        elif grep -q '"vue"' package.json 2>/dev/null; then
            project_type="Vue"
            expected_port="8080"
        elif grep -q '"nuxt"' package.json 2>/dev/null; then
            project_type="Nuxt"
            expected_port="3000"
        else
            project_type="Node.js"
            expected_port="3000"
        fi
        
    # Check for Python projects
    elif [ -f "manage.py" ] || [ -f "requirements.txt" ]; then
        if [ -f "manage.py" ]; then
            project_type="Django"
            expected_port="8000"
        else
            project_type="Python"
            expected_port="8000"
        fi
        
    # Check for other frameworks
    elif [ -f "Cargo.toml" ]; then
        project_type="Rust"
        expected_port="8080"
    elif [ -f "go.mod" ]; then
        project_type="Go"
        expected_port="8080"
    elif [ -f "composer.json" ]; then
        project_type="PHP"
        expected_port="8000"
    else
        project_type="Static HTML"
        expected_port="8000"
    fi
    
    echo "üì¶ Detected: $project_type (expected port: $expected_port)" >&2
    echo "$project_type|$expected_port"
}

find_safe_dev_servers() {
    echo "üîç Scanning for development servers..." >&2
    
    # Common dev server ports (ordered by priority)
    local common_ports=(3000 8000 9999 3001 3002 5173 8080 8888 9000 4000 5500)
    local dev_servers=()
    
    for port in "${common_ports[@]}"; do
        if lsof -i :$port >/dev/null 2>&1; then
            local process_name=$(lsof -i :$port | tail -1 | awk '{print $1}')
            
            # Only include processes that are clearly dev servers
            case "$process_name" in
                node|Node|python*|Python*|ruby|Rails|php|nginx|http-server|webpack*|vite|next*|live-server)
                    echo "   ‚úÖ Port $port: $process_name (dev server)" >&2
                    dev_servers+=("$port")
                    ;;
                *)
                    echo "   ‚ö™ Port $port: $process_name (system service - skipped)" >&2
                    ;;
            esac
        fi
    done
    
    echo "${#dev_servers[@]} ${dev_servers[@]}"
}

safe_port_selection() {
    local explicit_port="$1"
    
    # If port explicitly specified, use it (but verify it exists)
    if [ -n "$explicit_port" ]; then
        if lsof -i :$explicit_port >/dev/null 2>&1; then
            local process_name=$(lsof -i :$explicit_port | tail -1 | awk '{print $1}')
            echo "üéØ Using explicitly specified port $explicit_port ($process_name)" >&2
            echo "$explicit_port"
            return 0
        else
            echo "‚ùå Port $explicit_port is not in use" >&2
            echo "   üí° Make sure your dev server is running on this port" >&2
            return 1
        fi
    fi
    
    # Auto-detection: only proceed if exactly one dev server is running
    local servers_info=$(find_safe_dev_servers)
    local server_count=$(echo "$servers_info" | awk '{print $1}')
    local server_ports=($(echo "$servers_info" | awk '{for(i=2;i<=NF;i++) print $i}'))
    
    if [ "$server_count" -eq 0 ]; then
        echo "‚ùå No development servers detected" >&2
        echo "   üí° Start your dev server first, then:" >&2
        echo "   üí° Use: see-me [PORT] to specify the port explicitly" >&2
        return 1
    elif [ "$server_count" -eq 1 ]; then
        echo "üéØ Found exactly one dev server on port ${server_ports[0]}" >&2
        echo "${server_ports[0]}"
        return 0
    else
        echo "‚ö†Ô∏è  Multiple dev servers detected: ${server_ports[@]}" >&2
        echo "   üí° Please specify which port to use:" >&2
        for port in "${server_ports[@]}"; do
            local process_name=$(lsof -i :$port | tail -1 | awk '{print $1}')
            echo "   üí° see-me $port    # Connect to $process_name on port $port" >&2
        done
        return 1
    fi
}

wait_for_dev_server() {
    local max_wait=30  # seconds
    local wait_count=0
    
    echo "‚è≥ Waiting for dev server to start..."
    
    while [ $wait_count -lt $max_wait ]; do
        if find_running_dev_server >/dev/null 2>&1; then
            echo "‚úÖ Dev server detected!"
            return 0
        fi
        sleep 1
        wait_count=$((wait_count + 1))
        echo -n "."
    done
    
    echo ""
    echo "‚ùå Timeout waiting for dev server"
    echo "   Make sure your dev server started successfully"
    return 1
}

initialize_logging() {
    if [ ! -d ".devlogger" ]; then
        echo "üîß First time setup - initializing browser logging..."
        mkdir -p .devlogger
        
        # Create console wrapper
        cat > .devlogger/console-wrapper.js << 'EOF'
// DevLogger Console Wrapper - Captures browser console output
(function() {
    'use strict';
    
    const originalConsole = { ...console };
    const logs = [];
    const LOG_SERVER_URL = 'http://localhost:3333/save-log';
    const CLEAR_LOG_URL = 'http://localhost:3333/clear-logs';
    
    // Generate session ID to detect page refreshes
    const sessionId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    
    // Clear logs on page load (fresh start for each refresh)
    fetch(CLEAR_LOG_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sessionId: sessionId })
    }).catch(() => {}); // Ignore errors during clearing
    
    function hashMessage(msg) {
        try {
            return btoa(JSON.stringify(msg)).slice(0, 10);
        } catch (e) {
            return JSON.stringify(msg).slice(0, 10);
        }
    }
    
    function addLog(level, args) {
        const message = args.map(arg => 
            typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
        ).join(' ');
        
        const hash = hashMessage(message);
        const timestamp = new Date().toISOString();
        
        // Check for duplicates in current session only
        const existing = logs.find(log => log.hash === hash);
        if (existing) {
            existing.count++;
            existing.message = `${message} (seen ${existing.count} times)`;
        } else {
            logs.push({ hash, message, level, timestamp, count: 1 });
        }
        
        // Send to server with session ID
        const logEntry = existing || logs[logs.length - 1];
        fetch(LOG_SERVER_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                sessionId: sessionId,
                timestamp: logEntry.timestamp,
                level: level.toUpperCase(),
                message: logEntry.message
            })
        }).catch(() => {
            localStorage.setItem('devlogger-logs', JSON.stringify(logs));
        });
    }
    
    // Override console methods
    ['log', 'error', 'warn', 'info'].forEach(method => {
        console[method] = function(...args) {
            addLog(method, args);
            originalConsole[method].apply(console, arguments);
        };
    });
    
    // Capture uncaught errors
    window.addEventListener('error', (e) => {
        addLog('error', [`Uncaught Error: ${e.message}`, `at ${e.filename}:${e.lineno}`]);
    });
    
    window.addEventListener('unhandledrejection', (e) => {
        addLog('error', [`Unhandled Promise Rejection: ${e.reason}`]);
    });
    
    console.log('üîç see-me active - console output being captured');
})();
EOF

        # Create log server (same as before)
        cat > .devlogger/log-server.js << 'EOF'
const http = require('http');
const fs = require('fs');
const path = require('path');

const PORT = 3333;
const LOG_FILE = path.join(__dirname, 'browser.log');

let currentSession = null;

const server = http.createServer((req, res) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    if (req.method === 'OPTIONS') {
        res.writeHead(200);
        res.end();
        return;
    }
    
    if (req.method === 'POST' && req.url === '/clear-logs') {
        let body = '';
        req.on('data', chunk => body += chunk);
        req.on('end', () => {
            try {
                const data = JSON.parse(body);
                const newSessionId = data.sessionId;
                
                // Only clear if this is a new session (page refresh)
                if (currentSession !== newSessionId) {
                    currentSession = newSessionId;
                    fs.writeFileSync(LOG_FILE, ''); // Clear the log file
                    console.log(`üîÑ Page refresh detected - cleared logs (session: ${newSessionId.slice(0, 8)}...)`);
                }
                
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({success: true, cleared: currentSession === newSessionId}));
            } catch (err) {
                res.writeHead(400);
                res.end('Invalid JSON');
            }
        });
    } else if (req.method === 'POST' && req.url === '/save-log') {
        let body = '';
        req.on('data', chunk => body += chunk);
        req.on('end', () => {
            try {
                const log = JSON.parse(body);
                const logLine = `[${log.timestamp}] BROWSER ${log.level}: ${log.message}\n`;
                fs.appendFileSync(LOG_FILE, logLine);
                res.writeHead(200, {'Content-Type': 'application/json'});
                res.end(JSON.stringify({success: true}));
            } catch (err) {
                res.writeHead(400);
                res.end('Invalid JSON');
            }
        });
    } else {
        res.writeHead(404);
        res.end('Not found');
    }
});

server.listen(PORT, () => {
    console.log(`üåê see-me log server running on http://localhost:${PORT}`);
});
EOF

        # Create smart proxy
        cat > .devlogger/proxy.js << 'EOF'
const http = require('http');
const fs = require('fs');
const path = require('path');

const PROXY_PORT = 3334;
const TARGET_PORT = process.argv[2] || 3000;
const CONSOLE_SCRIPT = fs.readFileSync(path.join(__dirname, 'console-wrapper.js'), 'utf8');

console.log(`üîÑ Smart proxy: localhost:${PROXY_PORT} ‚Üí localhost:${TARGET_PORT}`);

const server = http.createServer((req, res) => {
    const proxyReq = http.request({
        hostname: 'localhost',
        port: TARGET_PORT,
        path: req.url,
        method: req.method,
        headers: req.headers
    }, (proxyRes) => {
        const contentType = proxyRes.headers['content-type'] || '';
        
        if (!contentType.includes('text/html')) {
            res.writeHead(proxyRes.statusCode, proxyRes.headers);
            proxyRes.pipe(res);
            return;
        }
        
        let body = '';
        proxyRes.on('data', chunk => body += chunk);
        proxyRes.on('end', () => {
            if (body.includes('<head>')) {
                const script = `<script>${CONSOLE_SCRIPT}</script>`;
                body = body.replace('<head>', `<head>${script}`);
            }
            
            res.writeHead(proxyRes.statusCode, {
                ...proxyRes.headers,
                'content-length': Buffer.byteLength(body)
            });
            res.end(body);
        });
    });
    
    proxyReq.on('error', () => {
        res.writeHead(502);
        res.end('Target server not available');
    });
    
    req.pipe(proxyReq);
});

server.listen(PROXY_PORT, () => {
    console.log(`üåê Visit http://localhost:${PROXY_PORT} (instead of localhost:${TARGET_PORT})`);
});
EOF

        echo "‚úÖ Browser logging initialized!"
    fi
    
    # Always start with fresh logs for new development session
    echo "üóëÔ∏è  Clearing previous browser logs for fresh session..."
    > .devlogger/browser.log
}

detect_newly_started_server() {
    echo "üîç Detecting newly started development server..." >&2
    
    # Wait a moment for backgrounded command to start
    sleep 2
    
    # Look for recent dev server processes (started within last 30 seconds)
    local max_attempts=10
    local attempt=0
    
    while [ $attempt -lt $max_attempts ]; do
        sleep 1
        attempt=$((attempt + 1))
        
        # Find all python/node processes and check their start time
        local current_time=$(date +%s)
        
        # Get all dev server processes with their PIDs
        ps -eo pid,lstart,comm,args | grep -E "(python.*server|node.*server|python.*http|ruby.*server|php.*server)" | grep -v grep | while read line; do
            local pid=$(echo "$line" | awk '{print $1}')
            local process_start_str=$(echo "$line" | awk '{print $2, $3, $4, $5, $6}')
            
            # Convert process start time to seconds (rough estimate)
            local process_start_time=$(date -j -f "%a %b %d %H:%M:%S %Y" "$process_start_str" +%s 2>/dev/null || echo 0)
            local age=$((current_time - process_start_time))
            
            # If process is less than 30 seconds old, check for listening ports
            if [ $age -lt 30 ]; then
                local listening_ports=$(lsof -Pan -p "$pid" -i 2>/dev/null | grep LISTEN | awk -F: '{print $2}' | awk '{print $1}' | sort -u)
                
                if [ -n "$listening_ports" ]; then
                    for port in $listening_ports; do
                        if lsof -i :$port >/dev/null 2>&1; then
                            local process_name=$(ps -p "$pid" -o comm= 2>/dev/null)
                            echo "   ‚úÖ Found recent $process_name server on port $port (PID: $pid)" >&2
                            echo "$port"
                            return 0
                        fi
                    done
                fi
            fi
        done
        
        # If no recent process found, try a simpler approach - find any python/node with http.server or similar
        local simple_match=$(ps -eo pid,args | grep -E "(python.*http\.server|python.*-m.*http|node.*server)" | grep -v grep | head -1)
        if [ -n "$simple_match" ]; then
            local pid=$(echo "$simple_match" | awk '{print $1}')
            local listening_ports=$(lsof -Pan -p "$pid" -i 2>/dev/null | grep LISTEN | awk -F: '{print $2}' | awk '{print $1}' | sort -u)
            
            if [ -n "$listening_ports" ]; then
                for port in $listening_ports; do
                    if lsof -i :$port >/dev/null 2>&1; then
                        local process_name=$(ps -p "$pid" -o comm= 2>/dev/null)
                        echo "   ‚úÖ Found $process_name server on port $port (PID: $pid)" >&2
                        echo "$port"
                        return 0
                    fi
                done
            fi
        fi
        
        echo "   ‚è≥ Waiting for dev server to start... (attempt $attempt/$max_attempts)" >&2
    done
    
    echo "   ‚ùå No dev server detected within timeout" >&2
    return 1
}

start_smart_logging() {
    local explicit_port="$1"
    initialize_logging
    
    local target_port
    
    if [ -n "$explicit_port" ]; then
        # Port explicitly specified
        if lsof -i :$explicit_port >/dev/null 2>&1; then
            target_port="$explicit_port"
            echo "üéØ Using specified port $target_port" >&2
        else
            echo "‚ùå Port $explicit_port is not in use" >&2
            return 1
        fi
    else
        # Auto-detect newly started server
        target_port=$(detect_newly_started_server)
        if [ $? -ne 0 ]; then
            echo ""
            echo "üí° Make sure to run: npm run dev & see-me"
            echo "üí° Or specify port manually: see-me [PORT]"
            return 1
        fi
    fi
    
    echo ""
    echo "üöÄ Starting smart browser logging for port $target_port..."
    
    # Stop any existing services
    pkill -f "log-server.js" 2>/dev/null || true
    pkill -f "proxy.js" 2>/dev/null || true
    
    # Start services
    /opt/homebrew/bin/node .devlogger/log-server.js &
    /opt/homebrew/bin/node .devlogger/proxy.js $target_port &
    
    sleep 2
    
    echo ""
    echo "üéâ see-me is active!"
    echo "üåê Visit: http://localhost:3334"
    echo "üìã View logs: see-me logs (in another terminal)"
    echo "üõë Stop: see-me stop (or Ctrl+C)"
    echo ""
    echo "üí° All browser console output is now automatically captured for agents!"
    echo ""
    echo "üîç Monitoring... (Press Ctrl+C to stop)"
    
    # Keep running and show live log updates
    trap 'echo ""; echo "üõë Stopping see-me..."; pkill -f "log-server.js" 2>/dev/null || true; pkill -f "proxy.js" 2>/dev/null || true; exit 0' INT
    
    # Follow logs if they exist, otherwise just wait
    if [ -f ".devlogger/browser.log" ]; then
        tail -f .devlogger/browser.log
    else
        # Just wait until interrupted
        while true; do
            sleep 1
        done
    fi
}

show_logs() {
    if [ -f ".devlogger/browser.log" ]; then
        echo "üìã Browser Console Logs:"
        echo "======================="
        cat .devlogger/browser.log
    else
        echo "üìã No logs found. Visit http://localhost:3334 to generate logs."
    fi
}

show_status() {
    echo "üìä see-me Status"
    echo "==============="
    
    if [ -d ".devlogger" ]; then
        echo "üìÅ Initialized: ‚úÖ"
    else
        echo "üìÅ Initialized: ‚ùå (will auto-initialize on first run)"
    fi
    
    if pgrep -f "log-server.js" >/dev/null; then
        echo "üåê Log server: ‚úÖ Running (port 3333)"
    else
        echo "üåê Log server: ‚ùå Stopped"
    fi
    
    if pgrep -f "proxy.js" >/dev/null; then
        local proxy_pid=$(pgrep -f "proxy.js")
        echo "üîÑ Proxy server: ‚úÖ Running (port 3334)"
    else
        echo "üîÑ Proxy server: ‚ùå Stopped"
    fi
    
    # Show detected project info
    if [ -f "package.json" ] || [ -f "manage.py" ] || [ -f "requirements.txt" ]; then
        local project_info=$(detect_project_type 2>/dev/null || echo "unknown|unknown")
        local project_type=$(echo "$project_info" | cut -d'|' -f1)
        echo "üì¶ Project type: $project_type"
    fi
    
    # Show current dev servers
    echo ""
    echo "üîç Running dev servers:"
    find_running_dev_server >/dev/null 2>&1 || echo "   None detected"
    
    if [ -f ".devlogger/browser.log" ]; then
        local log_count=$(wc -l < .devlogger/browser.log 2>/dev/null || echo 0)
        echo "üìã Logs captured: $log_count lines"
    fi
}

stop_services() {
    echo "üõë Stopping see-me services..."
    pkill -f "log-server.js" 2>/dev/null || true
    pkill -f "proxy.js" 2>/dev/null || true
    echo "‚úÖ Services stopped"
}

# Main execution
case "${1:-start}" in
    start|"")
        start_smart_logging
        ;;
    logs)
        show_logs
        ;;
    status)
        show_status  
        ;;
    stop)
        stop_services
        ;;
    help|--help|-h)
        show_help
        ;;
    [0-9]*)
        # Port number specified
        start_smart_logging "$1"
        ;;
    *)
        echo "‚ùå Unknown command: $1"
        echo "   Use 'see-me help' for usage"
        echo "   Or specify a port: see-me [PORT]"
        exit 1
        ;;
esac
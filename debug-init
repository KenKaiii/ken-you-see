#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

console.log('üîß Initializing debug logging for this project...');

// Create .debug directory
const debugDir = path.join(process.cwd(), '.debug');
if (!fs.existsSync(debugDir)) {
  fs.mkdirSync(debugDir);
  console.log('‚úÖ Created .debug/ directory');
} else {
  console.log('üìÅ .debug/ directory already exists');
}

// Create basic config
const config = {
  projectName: path.basename(process.cwd()),
  initialized: new Date().toISOString(),
  browser: {
    enabled: true,
    logFile: 'browser.log'
  },
  cli: {
    enabled: true,
    logFile: 'cli.log'
  }
};

const configPath = path.join(debugDir, 'config.json');
fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
console.log('‚öôÔ∏è  Created config.json');

// Create empty log files
const browserLogPath = path.join(debugDir, 'browser.log');
const cliLogPath = path.join(debugDir, 'cli.log');

if (!fs.existsSync(browserLogPath)) {
  fs.writeFileSync(browserLogPath, '');
  console.log('üìù Created browser.log');
}

if (!fs.existsSync(cliLogPath)) {
  fs.writeFileSync(cliLogPath, '');
  console.log('üìù Created cli.log');
}

// Create browser console wrapper
const consoleWrapperContent = `
// DevLogger Browser Console Wrapper
(function() {
  const originalConsole = {
    log: console.log,
    error: console.error,
    warn: console.warn,
    info: console.info
  };
  
  const logs = [];
  const logCounts = new Map();
  
  function addLog(level, args) {
    const message = args.map(arg => 
      typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
    ).join(' ');
    
    const timestamp = new Date().toISOString();
    const logEntry = \`[\${timestamp}] BROWSER \${level.toUpperCase()}: \${message}\`;
    
    // Simple deduplication
    const hash = btoa(message).slice(0, 10);
    if (logCounts.has(hash)) {
      logCounts.set(hash, logCounts.get(hash) + 1);
      const count = logCounts.get(hash);
      const dedupedEntry = \`[\${timestamp}] BROWSER \${level.toUpperCase()}: \${message} (seen \${count} times)\`;
      logs[logs.length - 1] = dedupedEntry;
    } else {
      logCounts.set(hash, 1);
      logs.push(logEntry);
    }
    
    // Keep only last 1000 logs to prevent memory issues
    if (logs.length > 1000) {
      logs.splice(0, 100);
    }
    
    // Immediately try to save to file system (if possible)
    saveLogs();
  }
  
  // Override console methods
  ['log', 'error', 'warn', 'info'].forEach(method => {
    console[method] = function(...args) {
      addLog(method, args);
      originalConsole[method].apply(console, arguments);
    };
  });
  
  // Capture uncaught errors
  window.addEventListener('error', function(e) {
    addLog('error', [\`Uncaught Error: \${e.message} at \${e.filename}:\${e.lineno}\`]);
  });
  
  // Capture unhandled promise rejections
  window.addEventListener('unhandledrejection', function(e) {
    addLog('error', [\`Unhandled Promise Rejection: \${e.reason}\`]);
  });
  
  // Save logs function - write directly to file system via Node.js bridge
  function saveLogs() {
    if (logs.length === 0) return;
    
    const logData = logs.join('\\n') + '\\n';
    
    // Strategy 1: Use File System Access API (if available)
    if (window.showSaveFilePicker) {
      // Modern browsers with file system access
      try {
        writeToFile(logData);
      } catch (e) {
        fallbackSave(logData);
      }
    } else {
      // Fallback for older browsers
      fallbackSave(logData);
    }
  }
  
  async function writeToFile(logData) {
    try {
      // Try to write to .debug/browser.log via File System Access API
      const handle = await window.showSaveFilePicker({
        suggestedName: 'browser.log',
        startIn: 'desktop',
        types: [{
          description: 'Log files',
          accept: { 'text/plain': ['.log'] }
        }]
      });
      const writable = await handle.createWritable({ keepExistingData: true });
      await writable.write(logData);
      await writable.close();
    } catch (e) {
      fallbackSave(logData);
    }
  }
  
  function fallbackSave(logData) {
    // Strategy 2: Try to POST to DevLogger server
    fetch('http://localhost:3333/devlogger-save', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        file: '.debug/browser.log',
        data: logData,
        timestamp: new Date().toISOString()
      })
    }).then(response => {
      if (response.ok) {
        console.log('üîß DevLogger: Browser logs saved to .debug/browser.log');
      } else {
        throw new Error('Server response not ok');
      }
    }).catch(() => {
      // Strategy 3: Save to localStorage and provide instructions
      localStorage.setItem('devlogger-browser-logs', logData);
      
      // Strategy 4: Auto-copy to clipboard if possible
      if (navigator.clipboard) {
        navigator.clipboard.writeText(logData).catch(() => {});
      }
      
      // Strategy 5: Show user how to save manually
      console.log('üìã DevLogger: Server not running - logs saved to localStorage');
      console.log('   Start server: node .debug/log-server.js');
      console.log('   Or run downloadDevLogs() to save manually');
    });
  }
  
  // Expose global function for manual log download
  window.downloadDevLogs = function() {
    const logData = logs.join('\\n') + '\\n';
    const blob = new Blob([logData], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = \`browser-logs-\${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.txt\`;
    a.click();
    URL.revokeObjectURL(url);
  };
  
  // Save every 10 seconds (more frequent)
  setInterval(saveLogs, 10000);
  
  // Save on page unload
  window.addEventListener('beforeunload', saveLogs);
  
  console.log('üîß DevLogger browser console wrapper initialized');
  console.log('   Call downloadDevLogs() to manually download logs');
})();
`;

const wrapperPath = path.join(debugDir, 'console-wrapper.js');
fs.writeFileSync(wrapperPath, consoleWrapperContent);
console.log('üåê Created browser console wrapper');

// Create shell functions file
const shellFunctionsContent = `
# DevLogger Shell Functions
# source .debug/shell-functions.sh

DEVLOGGER_CLI_LOG=".debug/cli.log"

# Store original command paths BEFORE defining any functions
DEVLOGGER_ORIG_NPM="$(command -v npm 2>/dev/null)"
DEVLOGGER_ORIG_YARN="$(command -v yarn 2>/dev/null)"
DEVLOGGER_ORIG_PYTHON="$(command -v python 2>/dev/null)"
DEVLOGGER_ORIG_PYTHON3="$(command -v python3 2>/dev/null)"
DEVLOGGER_ORIG_NODE="$(command -v node 2>/dev/null)"
DEVLOGGER_ORIG_CARGO="$(command -v cargo 2>/dev/null)"
DEVLOGGER_ORIG_DOCKER="$(command -v docker 2>/dev/null)"

function log_command() {
  local cmd="$1"
  shift
  local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")
  
  echo "[$timestamp] CLI: $cmd $*" >> "$DEVLOGGER_CLI_LOG"
  
  # Execute command and capture output
  local output
  local exit_code
  output=$("$cmd" "$@" 2>&1)
  exit_code=$?
  
  # Log the output (truncate if too long)
  if [ \${#output} -gt 1000 ]; then
    echo "[$timestamp] OUTPUT: \${output:0:1000}... (truncated)" >> "$DEVLOGGER_CLI_LOG"
  elif [ $exit_code -eq 0 ]; then
    echo "[$timestamp] OUTPUT: $output" >> "$DEVLOGGER_CLI_LOG"
  else
    echo "[$timestamp] ERROR: $output" >> "$DEVLOGGER_CLI_LOG"
  fi
  echo "[$timestamp] EXIT: $exit_code" >> "$DEVLOGGER_CLI_LOG"
  
  # Show original output to user
  echo "$output"
  
  return $exit_code
}

# Wrapper functions using stored paths
npm() {
  if [ -n "$DEVLOGGER_ORIG_NPM" ]; then
    log_command "$DEVLOGGER_ORIG_NPM" "$@"
  else
    echo "npm not found" >&2
    return 127
  fi
}

yarn() {
  if [ -n "$DEVLOGGER_ORIG_YARN" ]; then
    log_command "$DEVLOGGER_ORIG_YARN" "$@"
  else
    echo "yarn not found" >&2
    return 127
  fi
}

python() {
  if [ -n "$DEVLOGGER_ORIG_PYTHON" ]; then
    log_command "$DEVLOGGER_ORIG_PYTHON" "$@"
  else
    echo "python not found" >&2
    return 127
  fi
}

python3() {
  if [ -n "$DEVLOGGER_ORIG_PYTHON3" ]; then
    log_command "$DEVLOGGER_ORIG_PYTHON3" "$@"
  else
    echo "python3 not found" >&2
    return 127
  fi
}

node() {
  if [ -n "$DEVLOGGER_ORIG_NODE" ]; then
    log_command "$DEVLOGGER_ORIG_NODE" "$@"
  else
    echo "node not found" >&2
    return 127
  fi
}

cargo() {
  if [ -n "$DEVLOGGER_ORIG_CARGO" ]; then
    log_command "$DEVLOGGER_ORIG_CARGO" "$@"
  else
    echo "cargo not found" >&2
    return 127
  fi
}

docker() {
  if [ -n "$DEVLOGGER_ORIG_DOCKER" ]; then
    log_command "$DEVLOGGER_ORIG_DOCKER" "$@"
  else
    echo "docker not found" >&2
    return 127
  fi
}

# Manual logging function for other commands
dlog() {
  log_command "$@"
}

echo "üîß DevLogger shell functions loaded!"
echo "   Wrapped commands: npm, yarn, python, python3, node, cargo, docker"
echo "   Manual logging: dlog <command> [args...]"
`;

const shellFunctionsPath = path.join(debugDir, 'shell-functions.sh');
fs.writeFileSync(shellFunctionsPath, shellFunctionsContent);
console.log('üêö Created shell functions');

// Create simple log server for browser integration
const logServerContent = `#!/usr/bin/env node
const http = require('http');
const fs = require('fs');
const path = require('path');

const PORT = 3333;
const LOG_FILE = path.join(__dirname, 'browser.log');

const server = http.createServer((req, res) => {
  // Enable CORS for local development
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, GET, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  
  if (req.method === 'OPTIONS') {
    res.writeHead(200);
    res.end();
    return;
  }
  
  if (req.method === 'POST' && req.url === '/devlogger-save') {
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', () => {
      try {
        const data = JSON.parse(body);
        fs.appendFileSync(LOG_FILE, data.data);
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ success: true }));
      } catch (e) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: e.message }));
      }
    });
  } else {
    res.writeHead(404);
    res.end('Not found');
  }
});

server.listen(PORT, 'localhost', () => {
  console.log(\`üåê DevLogger server running on http://localhost:\${PORT}\`);
  console.log(\`üìù Browser logs will be saved to: \${LOG_FILE}\`);
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('\\nüõë DevLogger server shutting down...');
  server.close();
  process.exit(0);
});
`;

const serverPath = path.join(debugDir, 'log-server.js');
fs.writeFileSync(serverPath, logServerContent);
fs.chmodSync(serverPath, '755');
console.log('üñ•Ô∏è  Created log server for browser integration');

// Add to .gitignore
const gitignorePath = path.join(process.cwd(), '.gitignore');
const gitignoreEntry = '.debug/\n';

if (fs.existsSync(gitignorePath)) {
  const gitignoreContent = fs.readFileSync(gitignorePath, 'utf8');
  if (!gitignoreContent.includes('.debug/')) {
    fs.appendFileSync(gitignorePath, gitignoreEntry);
    console.log('üìù Added .debug/ to .gitignore');
  }
} else {
  fs.writeFileSync(gitignorePath, gitignoreEntry);
  console.log('üìù Created .gitignore with .debug/');
}

// Auto-add shell function sourcing to user's profile
const os = require('os');
const projectPath = process.cwd();
const shellFunctionsAbsolutePath = path.join(projectPath, '.debug/shell-functions.sh');

// Detect shell and profile file
const shell = process.env.SHELL || '/bin/bash';
const shellName = path.basename(shell);
let profileFile = '';

switch (shellName) {
  case 'zsh':
    profileFile = path.join(os.homedir(), '.zshrc');
    break;
  case 'bash':
    profileFile = path.join(os.homedir(), '.bashrc');
    if (!fs.existsSync(profileFile)) {
      profileFile = path.join(os.homedir(), '.bash_profile');
    }
    break;
  default:
    profileFile = path.join(os.homedir(), '.profile');
}

// Add sourcing line to profile if not already present
const sourceLine = `# DevLogger for ${config.projectName}\nif [ -f "${shellFunctionsAbsolutePath}" ]; then source "${shellFunctionsAbsolutePath}"; fi`;

if (fs.existsSync(profileFile)) {
  const profileContent = fs.readFileSync(profileFile, 'utf8');
  if (!profileContent.includes(shellFunctionsAbsolutePath)) {
    fs.appendFileSync(profileFile, `\n${sourceLine}\n`);
    console.log(`üîß Added auto-sourcing to ${profileFile}`);
  } else {
    console.log('üîß Shell profile already configured');
  }
} else {
  fs.writeFileSync(profileFile, `${sourceLine}\n`);
  console.log(`üîß Created ${profileFile} with auto-sourcing`);
}

console.log('\nüéâ DevLogger initialization complete!');
console.log('\nüìñ Usage:');
console.log('1. For browser logging:');
console.log('   ‚Ä¢ Include .debug/console-wrapper.js in your HTML');
console.log('   ‚Ä¢ Start log server: node .debug/log-server.js');
console.log('2. For CLI logging: Open a new terminal (auto-configured) or run:');
console.log(`   source "${shellFunctionsAbsolutePath}"`);
console.log('3. Agents can read logs from .debug/browser.log and .debug/cli.log');
console.log('\nüìÅ Files created:');
console.log('   .debug/config.json');
console.log('   .debug/browser.log');
console.log('   .debug/cli.log');
console.log('   .debug/console-wrapper.js');
console.log('   .debug/shell-functions.sh');
console.log('   .debug/log-server.js');
console.log(`\n‚ú® Shell functions will auto-load in new terminals via ${profileFile}`);
console.log('\nüöÄ Quick start:');
console.log('   Terminal 1: node .debug/log-server.js');
console.log('   Terminal 2: Open your web app with console-wrapper.js included');
console.log('   Terminal 3: Run CLI commands (auto-logged)');